# 词法分析器

在编译器理解输入程序的三个过程中，词法分析是第一阶段。词法分析器读取字符流，并产生单词流。它聚合字符形成单词，并应用一组规则来判断每个单词在源语言中是否合法。如果单词有效，词法分析器会分配给它一个语法范畴或词类。

## 概念路线图

1. 识别器：识别器是在字符流中识别特定单词的程序。有限自动机是识别器的一种形式化方法。
2. 正则表达式：正则表达式是一种用于定义语法的形式记号。
3. 一组构造方法，用于将正则表达式转换为识别器。
4. 实现词法分析器的三种不同的方式：表驱动词法分析器、直接编码的词法分析器和手工编码方法。

## 识别单词

逐字符的词法分析方法会让算法清晰易懂。我们可以用转移图表示逐字符处理的词法分析器，转移图又相当于一个有限自动机。转移图分为无环和有环，无限集需要有环的转移图。<br>
对于需要实现转移图（transition diagram）的代码来说，转移图充当了这些代码的抽象。转移图还可以看作是形式化的数学对象，成为有限自动机，它定义了识别器的规格。<br>
形式上，有限自动机（FA）是一个五元数组(S, ∑, δ, s<sub>0</sub>, S<sub>A</sub>)，其中各分量的含义如下所示：
- S是识别器中的有限状态集，
- ∑是识别器中使用的有限字母表。通常，∑是转移图中边的标签的合集。
- δ(s, c)是识别器的转移函数。它将每个状态s ∈ S和每个字符c ∈ ∑的组合(s, c)映射到下一个状态。在状态s<sub>i</sub>遇到输入字符c，FA将采用转移s<sub>i</sub>→<sup>c</sup>δ(s<sub>i</sub>, c)。
- s<sub>0</sub> ∈ S是指定的起始状态。
- s<sub>A</sub>是接受状态的集合，s<sub>A</sub> ⊆ S。 s<sub>A</sub>中的每个状态都在转移图中表示为双层圆圈。

FA接受字符串的三种情况：
1. （正确）每个字符输入符合相应的状态转移，并在耗尽所有字符输入后处于接受状态。
2. （错误）FA在处理字符串时遇到错误——即某个字符x<sub>j</sub>可能使FA转移到错误状态s<sub>e</sub>。这种情况表明发生了词法错误。
3. （错误）FA耗尽其输入后，终止于s<sub>e</sub>之外的某个非接受状态。


## 正则表达式

有限自动机F所接受的单词的集合，形成了一种语言，记作L(F)。FA的转移图详细地定义了该语言，但转移图不够直观。对于任意FA，我们还可以使用一种称为正则表达式（Regular Expression, RE）的符号表示法来描述其语言。通过RE描述的语言称为正则语言。<br>
一个RE描述了一个定义在某个字母表∑上的字符串集合，外加一个表示空串的字符ε。我们将字符串的这种集合称为一种语言。一个RE由三个基本的操作构建而成：

1. 选择
2. 链接
3. 闭包：分为柯林闭包R<sub>\*</sub>和正闭包R<sub>+</sub>

其他操作有：求补运算符^，转义序列。

操作优先级：
- 括号 > 求补 > 闭包 > 连接 > 选择

FA的开销：
- FA的运行开销与输入长度成正比，和生成FA的RE长度或复杂性无关。更复杂的RE可能产生具有更多状态的FA，而这种FA又需要更多空间。

程序设计语言和自然语言的异同：
- 针对英文的词法分析器也可以使用基于FA的技术来识别可能的单词，因为所有的英语单词都取自一个有限的字母表。但此后，词法分析器还必须在字典中查找目标单词，以判断是否是一个真实存在的单词。同时，在很多情况下，要从语法上理解上下文才能归类此单词。有些情况下对单词及其上下文都需要进行语义上的理解。
- 相对而言，程序设计语言中的单词几乎总是从词法上就能够规定的，如`[a...z]([a...z]|[0...9])*`定义了Algol标志符的一个子集，而无需通过查找进行证实。当然，一些标志符可以保留用做关键字。但这些例外情况也可以从词法上规定，不需要上下文。

## 从正则表达式到词法分析器

![构造法的循环](/res/构造法的循环.png)

对于有限自动机来说，我们的目标是，使得从一组RE导出可执行词法分析器的过程自动化。

### 非确定性有限自动机

#### NFA与DFA的异同

- RE中将空串规定为ε，在FA中ε也有应用。ε转移是针对空串输入ε进行的转移，不会改变输入流中的读写位置。可以使用针对ε输入的转移来合并FA，并组成更复杂RE的FA。
- 但利用ε转移合并两个FA，可能会使关于FA工作方式的模型复杂化。
- 如果一个FA包含了一种对单个输入字符有多种可能的转移的状态，则称为非确定性有限自动机。即DFA就是允许在空串输入ε上进行转移的FA。
- 相反，如果FA中的每个状态对任一输入字符都具有唯一可能的转移，则称为确定性有限自动机。DFA不允许ε转移。

#### NFA的两种解释模型

1. 每次NFA必须进行非确定性选择时，如果有使得输入字符串转向接受状态的转移存在，则采用这样的转移。本质上，NFA在每个状态都需要猜测正确的转移。
2. 每次NFA必须进行非确定性选择时，NFA都克隆自身，以追踪每个可能的转移。因而，对于一个给定的输入字符，NFA实际上是处于一个特定的状态集合，其中每个状态都由NFA的某个克隆来处理。NFA并发地追踪所有转移路径。在任一时刻，存在NFA克隆副本活动状态的那些集合称为NFA的配置。当NFA到达一个配置，此时NFA已经耗尽输入字符串，且配置中的一个或多个克隆副本处于某个接受状态，则NFA接受该输入字符串。

#### NFA与DFA的等价性

NFA和DFA在表达力上是等价的。任何DFA都是某个NFA的一个特例。任何NFA都可以通过一个DFA模拟，这一事实可以通过子集构造法确立。

### 从正则表达式到NFA：Thompson构造法

Thompson构造法有一个模版，用于构建对应于单字母RE的NFA，还有一种NFA上的转换，模拟了连接、选择和闭包等各个基本RE运算符的效果。

1. a的NFA ![a的NFA](/res/a的NFA.png)
2. b的NFA ![b的NFA](/res/b的NFA.png)
3. ab的NF ![ab的NFA](/res/ab的NFA.png)
4. a|b的NFA ![a|b的NFA](/res/a或b的NFA.png)
5. a\*的NFA ![a*的NFA](/res/a闭包的NFA.png)

这个构造法从为输入RE中每个字符构建简单的NFA开始。接下来，它按照优先级和括号规定的顺序，对简单NFA的集合应用选择、连接和闭包等转换。对于a(b|c)\*，按a、b、c、b|c（括号优先级最高）、(b|c)\*（闭包先于连接）、a(b|c)\*的顺序构建。

### 从NFA到DFA：子集构造法

#### 目标

- 子集构造法以NFA(N, ∑, δ<sub>N</sub>, n<sub>0</sub>, N<sub>A</sub>)为输入，生成一个DFA(D, ∑, δ<sub>D</sub>, d<sub>0</sub>, D<sub>A</sub>)。
- NFA和DFA使用同样的字母表∑，DFA的起始状态d<sub>0</sub>和接受状态D<sub>A</sub>可通过构造法逐渐得到。
- 复杂的部分是从N推导D，以及推导δ<sub>D</sub>。

#### 算法

- 该算法构造了一个集合Q，其每个元素qi都是N（NFA的状态集合）的一个子集。这个算法中qi都是NFA的一个有效配置（NFA的各个配置中，可以通过某个输入字符串到达的配置）。
- 集合WorkList与集合Q有着同种元素。
- 函数ε-closure(S)的输入S是一个由NFA状态构成的集合，该计算检查每个状态si ∈ S，并将从si出发通过一个或多个ε转移所能达到的任何状态都添加到S中，并返回集合S。
- 函数Delta(q, c)将NFA的转移函数应用到集合q中的每个元素，返回∪<sub>s∈q</sub>δ<sub>N</sub>(s, c)，即转移后的状态的集合。

```
q0 = ε-closure({n0})
Q = {q0}
WorkList = {q0}

while (WorkList != 0)
    remove q from WorkList
    for each character c ∈ ∑
        t = ε-closure(Delta(q, c))
        T[q, c] = t
        if t ∉ 0
            add t to Q and to WorkList
```

- q0是NFA起始状态n0的ε转移所到达状态的集合，Q和WorkList最初仅只有q0一个元素。
- 每经过一次while循环，WorkList中移出一个有效配置q。对于每个字符c（内层循环），q读取c后转移并ε转移到的状态的集合构成新配置t。
- t将转移（配置和字符）记录在表T中，并加入集合Q和WorkList。
- 在该算法停止时，每个qi ∈ Q都对应于DFA中的一个状态di ∈ D。
- 因为NFA的有效配置是有限的，每个配置在WorkList上只出现一次，所以while循环必定会停止。
- Q可能会很庞大，其中包含的配置数最大可达|2<sup>N</sup>|（N的所有子集的集合）个。但因子集构造法导致的状态集膨胀，并不影响DFA的运行时间。

子集构造法到此并未结束，我们需要从得到的Q和T中构造出D（DFA的状态集）、d<sub>0</sub>、D<sub>A</sub>和δ<sub>D</sub>，这个过程很简单：

- 每个qi ∈ Q都需要一个DFA状态di ∈ D来表示。
- NFA起始状态q0对应的d0即DFA的起始状态。
- 如果qi包含NFA的某个接受状态，则对应的di就是DFA的接受状态之一。
- 遵从qi到di的映射，从T构造出转移函数δ<sub>D</sub>。如T[qi, c]等于qj，即qi接受字符c后转移到qj，则δ<sub>D</sub>(di, c)为dj。

#### 不动点计算

子集构造法是不动点计算的一个例子，这是一种在计算机科学中经常出现的计算方法。这种计算的特点在于，对取自某个结构已知的域中的集族，重复应用一个单调函数。当计算到达某个状态时，如果进一步的迭代只能得出已有的结果，那么计算将终止，这相当于连续的迭代空间中遇到了一个“不动点”。

#### 离线计算ε-closure

这里给出一个ε-closure的离线算法，对NFA转移图中的每个状态n计算ε-closure({n})，该算法是不动点计算的一个例子

```
for each state n ∈ N
    E(n) = {n}

WorkList = N
while (WorkList != ∅)
    remove n from WorkList
    t = {n}
    for each p that n-ε->p ∈ δ
        t = t ∪ E(p)
    if t != E(n)
        E(n) = t
        WorkList = WorkList ∪ {m|m-ε->n ∈ δ}
```

将NFA转移图看作由结点和边构成的图：

- 该算法首先为每个结点创建一个集合E。对于状态n，E(n)包含当前对ε-closure({n})的近似。
- 最初，对每个结点n都将E(n)设置为{n}，并将每个状态都放置在WorkList上。
- while循环的每次迭代都从WorkList中删除一个状态n，并找到从n出发的所有ε转移，并将转移的目标结点添加到E(n)。如果计算改变了E(n)，那么它会将在ε转移路径上的前驱结点放置到WorkList上。（如果n在其前驱结点的ε-closure中，那么向E(n)添加结点时，这些结点同样会添加到前驱结点对应的集合E中）。
- 对WorkList使用位向量集合可以确保算法不会将同一结点的名字放入WorkList两次。
