# 顺序容器

## 概述

- 一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与**元素加入容器时的位置**相对应。与之相对的，有序和无序关联容器，则根据关键字的值来存储元素。
- 标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。
- 所有顺序容器都提供了快速顺序访问元素的能力，但是，这些容器在以下方面都有不同的性能折中：
    - 向容器添加或从容器中删除元素的代价。
    - 非顺序访问容器中元素的代价。
- 顺序容器类型：
    - vector：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。
    - deque：双端队列。支持快速随机访问。在头尾位置插入／删除元素速度很快。
    - list：双向链表。只支持双向顺序访问。在list中任何位置进行插入／删除操作速度都很快。
    - forward_list：单向链表。只支持单向顺序访问。在链表任何位置进行插入／删除操作速度都很快。
    - array：固定大小数组。支持快速随机访问。不能添加或删除元素。（相比内置数组更安全、更容易使用）
    - string：与vector相似的容器，专门用于保存字符。
- 新标准库的容器比旧版本的快得多，现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。

##### 确定使用哪种顺序容器

- 通常，使用vector是最好的选择。
- 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
    - 首先，确定是否真的需要在容器中间位置添加元素。通常可以先向vector追加数据，然后再调用标准库的sort函数。
    - 如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。

## 容器库概览

容器类型上的操作形成了一种层次：
- 某些操作是所有容器类型都提供的。
- 另外一些操作仅针对顺序容器、关联容器或无序容器。
- 还有一些操作只适用于一小部分容器。

一般来说，每个容器都定义在一个头文件中，文件名和类型名相同。如，deque定义在头文件deque中。容器均定义为模版类。我们必须提供额外信息来生成特定的容器类型。

##### 对容器可以保存的元素类型的限制

- 顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另一个容器。如`vector<vector<string>> lines;`。（较旧的编译器可能需要在两个尖括号之间键入空格，例如，`vector<vector<string> >`）
- 某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况就只能使用那些没有特殊要求的容器操作了。例如，顺序容器构造函数的一个版本接受容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认的构造函数。
```CPP
vector<noDefault> v1(10, init);    // 正确：提供了元素初始化器
vector<noDefault> v2(10);          // 错误：必须提供一个元素初始化器
```
- 容器操作分类：类型别名、构造函数、赋值与swap、大小、添加／删除元素（不适用于array）、获取迭代器、反向容器的额外成员（不支持forward_list）。
- 容器操作列表：见书P295。

### 迭代器

- 与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。（如解引用、递增运算符）
- 有一个例外不符合公共接口的特点：forward_list迭代器不支持递减运算符（--）。
- 一个**迭代器范围**（iterator range）由一对迭代器表示，两个迭代器（begin和end）分别指向同一个容器中的元素或者是尾元素之后的位置。
- 迭代器范围中的元素包含first所表示的元素以及从begin开始直至end（但不包含end）之间的所有元素，这种元素范围被称为左闭合区间（left-inclusive interval），即[begin, end)。

##### 使用左闭合范围蕴含的编程假定

- 如果begin与end相等，则范围为空。
- 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。
- 我们可以对begin递增若干次，使得begin == end。

### 容器类型成员

- 每个容器都定义了多个类型，如size_type、iterator和const_iterator。
- 大多数容器还提供反向迭代器，即一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行++操作，会得到上一个元素。

### begin和end成员

- begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。
- begin和end有多个版本：带r的版本返回反向迭代器；以c开头的版本则返回const迭代器；以cr开头的版本返回const反向迭代器。
- 以c开头的版本是C++新标准引入的，用以支持auto与begin和end函数结合使用。过去只能显式声明希望使用哪种类型的迭代器。
```CPP
auto it1 = a.begin();       // 仅当a是const时，it1是const_iterator
auto it2 = a.cbegin();      // it2是const_iterator
```
- 当不需要写访问时，应使用cbegin和cend。

### 容器定义和初始化

容器的构造函数 | 特点
:----- | :-----:
`C c` | 默认构造函数。如果C是一个array，则c中元素按默认方式初始化；否则c为空。
`C c1(c2)`<br>`C c1=c2` | c1初始化为c2的拷贝。c1和c2必须是相同类型（相同的容器类型和元素类型，对于array类型，还必须是相同大小）
`C c{a,b,c...}`<br>`C c={a,b,c...}` | c1初始化为初始化列表中元素的拷贝。元素类型必须相容。对于array来说，列表中元素必须等于或小于array的大小。
`C c(b,e)` | c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与c的元素类型相容（array不适用）。
`C seq(n)` | seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的。（string不适用）
`C seq(n,t)` | seq包含n个初始化为值t的元素。

##### 将一个容器初始化为另一个容器的拷贝

- 讲一个新容器创建为另一个容器的拷贝的方法有两种：
    - 可以直接拷贝整个容器。
    - 或者（array除外）拷贝由一个迭代器对指定的元素范围。
- 容器拷贝：为创建一个容器对另一个容器的拷贝，两个**容器的类型**及其**元素类型**必须匹配。
- 迭代器范围拷贝：不过，当传递迭代器参数来拷贝一个范围时，就**不要求**容器类型是相同的了。而且两个容器中的元素类型也可以不同，只要能将要拷贝的元素转换。
```CPP
vector<const char*> articles = {"a", "an", "the"};
vector<string> words1(articles);                                // 错误：容器的拷贝，容器类型和元素类型必须匹配
forward_list<string> words2(articles.begin(), articles.end());  // 正确：迭代器范围拷贝，可以将const char*元素转换为string
```
- 注意：迭代器范围拷贝中，两个迭代器分别标记想要拷贝的第一个元素和**最后一个元素之后**的位置。（左闭合区间）

##### 列表初始化

- 在新标准中，可以对一个容器进行列表初始化。
```CPP
vector<const char*> articles = {"a", "an", "the"};
```
- 这样做显式地指定了容器中每个元素的值。对于除array之外的容器类型，还隐含地指定了容器的大小。

##### 与顺序容器大小相关的构造函数

- 除了与关联容器相同的构造函数外，顺序容器（array除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器。如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值。
- 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。
```CPP
vector<int> ivec(10, -1);   // 提供元素初始值。10个元素都初始化为-1
forward_list<int> ivec(10); // 不提供元素初始值。10个元素，每个都默认初始化为0
```

##### 标准库array具有固定大小

- 和内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小。
- 使用array类型也要同时指定元素类型和大小。
```CPP
array<string, 10>
array<int, 10>::size_type i;    // 数组类型包括元素类型和大小
```
- array不支持普通的容器构造函数，这些构造函数都或显式地，或隐式地确定容器的大小。
- 与其他容器不同，一个默认构造的array是非空的，它包含了和其大小一样多的被默认初始化的元素。
- 如果对array进行列表初始化，初始值的数目必须等于或小于array的大小。若小于，则剩余元素会进行值初始化。
```CPP
array<int, 10> ia1; // 10个默认初始化的int
array<int, 10> ia3; // ia[0]为422，剩余元素为0
```
- 虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制。
```CPP
int digs[5] = {0, 1, 2, 3, 4};
int cpy[5] = digs;              // 错误：内置数组不支持拷贝或赋值
array<int, 5> digits = {0, 1, 2, 3, 4};
array<int, 5> copy = digits;    // 正确：只要类型匹配（大小和元素类型），array可以拷贝或赋值
```

### 赋值和swap

容器赋值运算语句 | 特点
:---- | :-----:
c1=c2 | 将c1中的元素替换为c2中元素的拷贝
c={a,b,c...} | 将c1中元素替换为初始化列表中元素的拷贝（array不适用）
swap(c1,c2) | 交换c1和c2中的元素。c1和c2必须有相同的类型。swap通常比从c2向c1拷贝元素快得多
seq.assign(b,e) ｜ 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素
seq.assign(il) | 将seq中的元素替换为初始化列表il中的元素
seq.assign(n,t) | 将seq中的元素替换为n个值为t的元素

- assign操作不适用于关联容器和array。
- 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为array和string的情况除外）。

##### 使用assign（仅顺序容器）

- 赋值运算符（=）要求左边和右边的运算对象具有相同的类型。顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。
```CPP
list<string> names;
vector<const char*> oldstyle;
names = oldstyle;                                   // 错误：容器类型不匹配
names.assign(oldstyle.cbegin(), oldstyle.cend());   // 正确：可以将const char*转换为string
```
- assign还有两种其他版本，分别接受一个整形值加一个元素值，和一个初始化列表。

##### 使用swap

- swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换。（容器大小性质同时也会交换）
- 除array外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap只是交换了两个容器的数据结构（不对元素进行拷贝、删除或插入操作）。
- 元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了（如，iter在swap之前指向svec[3]的元素，那么swap之后它指向svec2[3]的元素）。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。
- 特别地是，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。因此，对于swap后的array，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。
- 在新标准库中，容器既提供成员函数版本的swap，也提供非成员函数版本的swap。早期标准库只提供成员函数版本的。非成员版本的swap在泛型编程中是非常重要的。统一使用非成员版本的swap是一个好习惯。

### 容器大小操作

- 每个容器都有三个与大小相关的操作。成员函数size返回容器中元素的数目；empty在size为0时返回true，否则返回false；max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。（forward_list不支持size）

### 关系运算符

- 每个容器类型都支持相等运算符（==和=）
