# 顺序容器

## 概述

- 一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与**元素加入容器时的位置**相对应。与之相对的，有序和无序关联容器，则根据关键字的值来存储元素。
- 标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。
- 所有顺序容器都提供了快速顺序访问元素的能力，但是，这些容器在以下方面都有不同的性能折中：
    - 向容器添加或从容器中删除元素的代价。
    - 非顺序访问容器中元素的代价。
- 顺序容器类型：
    - vector：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。
    - deque：双端队列。支持快速随机访问。在头尾位置插入／删除元素速度很快。
    - list：双向链表。只支持双向顺序访问。在list中任何位置进行插入／删除操作速度都很快。
    - forward_list：单向链表。只支持单向顺序访问。在链表任何位置进行插入／删除操作速度都很快。
    - array：固定大小数组。支持快速随机访问。不能添加或删除元素。（相比内置数组更安全、更容易使用）
    - string：与vector相似的容器，专门用于保存字符。
- 新标准库的容器比旧版本的快得多，现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。

#### 确定使用哪种顺序容器

- 通常，使用vector是最好的选择。
- 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
    - 首先，确定是否真的需要在容器中间位置添加元素。通常可以先向vector追加数据，然后再调用标准库的sort函数。
    - 如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。

## 容器库概览

容器类型上的操作形成了一种层次：
- 某些操作是所有容器类型都提供的。
- 另外一些操作仅针对顺序容器、关联容器或无序容器。
- 还有一些操作只适用于一小部分容器。

一般来说，每个容器都定义在一个头文件中，文件名和类型名相同。如，deque定义在头文件deque中。容器均定义为模版类。我们必须提供额外信息来生成特定的容器类型。

#### 对容器可以保存的元素类型的限制

- 顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另一个容器。如`vector<vector<string>> lines;`。（较旧的编译器可能需要在两个尖括号之间键入空格，例如，`vector<vector<string> >`）
- 某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况就只能使用那些没有特殊要求的容器操作了。例如，顺序容器构造函数的一个版本接受容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认的构造函数。
```CPP
std::vector<noDefault> v1(10, init);    // 正确：提供了元素初始化器
std::vector<noDefault> v2(10);          // 错误：必须提供一个元素初始化器
```
- 容器操作分类：类型别名、构造函数、赋值与swap、大小、添加／删除元素（不适用于array）、获取迭代器、反向容器的额外成员（不支持forward_list）。
- 容器操作列表：见书P295。

### 迭代器

- 与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。（如解引用、递增运算符）
- 有一个例外不符合公共接口的特点：forward_list迭代器不支持递减运算符（--）。
- 一个迭代器范围（iterator range）由一对迭代器表示，两个迭代器（begin和end）分别指向同一个容器中的元素或者是尾元素之后的位置。
- 迭代器范围中的元素包含first所表示的元素以及从begin开始直至end（但不包含end）之间的所有元素，这种元素范围被称为左闭合区间（left-inclusive interval），即[begin, end)。

#### 使用左闭合范围蕴含的编程假定

- 如果begin与end相等，则范围为空。
- 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。
- 我们可以对begin递增若干次，使得begin == end。

### 容器类型成员

- 每个容器都定义了多个类型，如size_type、iterator和const_iterator。
- 大多数容器还提供反向迭代器，即一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行++操作，会得到上一个元素。

### begin和end成员

- begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。
- begin和end有多个版本：带r的版本返回反向迭代器；以c开头的版本则返回const迭代器；以cr开头的版本返回const反向迭代器。
- 以c开头的版本是C++新标准引入的，用以支持auto与begin和end函数结合使用。过去只能显式声明希望使用哪种类型的迭代器。
```CPP
auto it1 = a.begin();       // 仅当a是const时，it1是const_iterator
auto it2 = a.cbegin();      // it2是const_iterator
```
- 当不需要写访问时，应使用cbegin和cend。

### 容器定义和初始化

容器定义和初始化语句 | 特点
:----- | :-----:
`C c` | 默认构造函数。如果C是一个array，则c中元素按默认方式初始化；否则c为空。
`C c1(c2)`<br>`C c1=c2` | c1初始化为c2的拷贝。c1和c2必须是相同类型（相同的容器类型和元素类型，对于array类型，还必须是相同大小）
`C c{a, b, c...}`<br>`C c={a, b, c...}` | c1初始化为初始化列表中元素的拷贝。元素类型必须相容。对于array来说，列表中元素必须等于或小于array的大小。
`C c(b, e)` | c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与c的元素类型相容（array不适用）。
`C seq(n)` | seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的。（string不适用）
`C seq(n, t)` | seq包含n个初始化为值t的元素。
